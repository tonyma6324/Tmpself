在正常的编程中，我们经常遇见栈溢出的情况（因为你从来不检查长度），发明编译器的人也大概猜到你小子会把程序折腾成什么样，分配给栈的内存空间已经足够的大，一般难以溢出。但总有意外的情况出现，比如你疯狂的进行递归调用，在函数里定义了一大堆变量，而且这些变量还贼大。你哐哐一堆猛敲，栈苦不堪言。

或者是最常见的情况，拷贝时没有对边界进行检查，数组下标或者指针越界了，甚至很多栈攻击的原理都是利用溢出来覆盖返回地址，从而攻击系统。

那么栈怎么就溢出了，作为缓冲区溢出的一种，它将成为我们深入理解计算机系统的入口，一探底层的原理，在这个专栏中，因为作为新进员工，这只是我一点个人的学习体会，可能会有很多的漏洞与谬误，希望大家不吝指出，我将及时改正。

说到栈溢出，我们就会说到栈，说到栈又会说到堆，在内存分配的问题上，我们常常被弄得晕头转向。特别内存上的问题有时需要汇编的帮助，汇编语言和高级语言的体系完全不同，各种寄存器移来移去，写来写去，意义不明。特别是不同的指令集架构，汇编往往不太一样，更加令人望而却步。


  那我们就从最普通的程序开始，我们都知道进程才是一个程序运行的实体，在我们按下回车键，运行生成的可执行文件后。操作系统会为我们的程序创建一个进程，并在内存中给程序分配运行空间，我们称之为进程空间。那么内存空间到底根据谁来分配，我们不同的变量又是放在哪里，栈溢出又是怎么影响我们的程序和攻击我们的呢？让我们回到main.c.                        20210910102339457.png        

一，BSS段为什么要清零？不为什么，因为他是BSS段


大伙都说，程序由BSS段，DATA段，CODE段组成，既然都这么说那应该是对的，在main.c编译生成了a.out文件后，其中同样也有BSS段，DATA段和CODE段。
下面给大家小粘一段定义。

bss段：
bss段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。

　bss是英文Block Started by Symbol的简称。
　bss段属于静态内存分配。 

data段：

　　数据段（data segment）通常是指用来存放程序中已初始化的全局变量或者静态变量的一块内存区域。

　　数据段属于静态内存分配。

code段：

　　代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。

　　这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。

　　在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。



  在运行可执行文件后，我们知道文件中的bss，data，code段就会加载到进程地址空间中。但不仅如此，我们还可以发现在a.out文件前面还有a.out魔术字，a.out段信息等字段。他们的作用又是什么呢？这时候就要请出我们神奇的readelf了，ELF文件格式中的段表(Section Table)中存放了各个段的各种信息，比如段的名字、段的类型、段在elf文件中的偏移、段的大小等信息。

                                                                                    2021091102290930649.jpeg

   我们不难发现，魔术字magic number常常是一串十六进制数，用来标识这个a.out文件，而段信息记载了关于本文件的一些重要信息，比如入口的地址等等。我们只需要有所了解即可。在加载时，我们要注意的是code和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化（清零）。

  停停停！怎么绕来绕去的，bss段到底在哪，它不是用来保存未初始化的全局变量的吗？怎么它又不在可执行文件中了，那加载时该怎么办？啥又叫bss段由系统来清零？等等，未初始化的全局变量本来就是0，还清零干嘛？

  我们先看看可执行文件是怎么被加载的

                                                                   7345261-fc11ac4827116f2d.png

在可执行文件被加载到内存中后，linux的虚拟地址空间的结构如上图所示。BSS，DATA，CODE段分别对应着.bss （图里多打了个a），.data，.text段。

那.bss段不是从可执行文件中加载的吗？我们可以做一个小小的实验。

                                                                                                                         

                                             2021091101391658558.jpeg                                          2021091102035021574.jpeg

上面两个程序唯一的区别就是有没有对a[1000]进行初始化，我们可以看看两者生成了可执行文件之后是什么样的。左边是未初始化的，右边是初始化过的。

 首先是a.out的文件大小比较，我们可以发现  

                                                                       2021091101394202563.jpeg    2021091102231306644.jpeg

未初始化的生成的可执行文件明显小于初始化过的，这时我们可以看看a.out文件的size是个什么情况。



                                                       2021091102070107581.jpeg     2021091102030943569.jpeg

可以非常清楚的发现前者的bss段的size远大于后者，后者的data段反而增加了差不多四千个字节的大小，但是这并不能解释为什么前者的大小远小于后者。

那么到底是为什么呢，明明两者总size相差无几，可在磁盘中的大小相去甚远。

排除一切其他的可能，即使剩下的那个再不可能也是真相——那就是除非bss段中的数据是不占磁盘空间的。

对！bss段不占磁盘空间！一切都变的合理了起来，但又有新的问题出现了，如果bss不占空间，那可执行文件加载到内存中的时候，一定有什么东西标识了bss段

计算机不会未卜先知，怎么才能获取到符号和大小呢。

没错，这时候又要请出我们的readelf了

                                                                          2021091302043945299.jpeg            

                                                                       2021091302024526293.jpeg                    

通过查看段表，我们可以先到节头里去找，每个段中，会有代码或者数据被划分为不同的节，节头表是对这些节位置和大小的描述，我们可以在里面发现bss段的大小，那符号呢？同样的，我们在.symtab节去找，就能找到bss段中的符号，包括GLOBAL来标识它是一个全局变量。

真相大白了，bss段的符号和大小都是存在段表中的，等加载进内存时候就按照标识分配大小，但它本身不占可执行文件的磁盘空间，不然这么多位置全拿来存0也过于铺张浪费了。

这下也能解释bss段在被加载时到底为什么要清零了，看似是在把为零的段清零，实际上也是在根据段表里的标识为bss段分配空间。

我们突然可以明白bss段这样设计的原因了，其实就是为了节省空间，不然这么多0来占据磁盘，没有什么必要。

如果下次有人问你bss段为什么要清零，你当然可以不厌其烦的为他解释，从main.c开始。

当然，你还有一种选项，那就是告诉他，因为它是bss段。



二，栈与金丝雀与递归

我们顺便探讨下栈的结构，以及多次递归为什么会消耗栈空间
我们都知道栈空间一般在进程空间上固定分配，栈空间的大小一般也是可以由配置来设定
在我们调用一个函数的同时到底发生了什么
我们可以反汇编一个函数来看看

00000ed4 <__skb_try_recv_from_queue>:
	if (unlikely(flags & MSG_PEEK && *off >= 0)) {
     ed4:	e2122002 	ands	r2, r2, #2            //将r2寄存器的值与立即数2按位与 然后放回r2 可以发现这个就是 flags & MSG_PEEK 

{
     ed8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
     edc:	e1a07003 	mov	r7, r3
	int _off = 0;
     ee0:	01a05002 	moveq	r5, r2
	bool peek_at_off = false;
     ee4:	01a03002 	moveq	r3, r2
	if (unlikely(flags & MSG_PEEK && *off >= 0)) {
     ee8:	0a000004 	beq	f00 <__skb_try_recv_from_queue+0x2c>
     eec:	e5975000 	ldr	r5, [r7]
     ef0:	e3550000 	cmp	r5, #0
	int _off = 0;
     ef4:	b3a05000 	movlt	r5, #0
		peek_at_off = true;
     ef8:	a3a03001 	movge	r3, #1
	bool peek_at_off = false;
     efc:	b1a03005 	movlt	r3, r5
	*last = queue->prev;
     f00:	e591c004 	ldr	ip, [r1, #4]
     f04:	e59d001c 	ldr	r0, [sp, #28]
     f08:	e580c000 	str	ip, [r0]
	skb_queue_walk(queue, skb) {
     f0c:	e5914000 	ldr	r4, [r1]
     f10:	e1540001 	cmp	r4, r1
     f14:	0a000040 	beq	101c <__skb_try_recv_from_queue+0x148>
		if (flags & MSG_PEEK) {
     f18:	e3520000 	cmp	r2, #0
     f1c:	0a000033 	beq	ff0 <__skb_try_recv_from_queue+0x11c>
			if (peek_at_off && _off >= skb->len &&
     f20:	e3530000 	cmp	r3, #0
     f24:	e5940060 	ldr	r0, [r4, #96]	; 0x60
     f28:	0a000009 	beq	f54 <__skb_try_recv_from_queue+0x80>
     f2c:	e1500005 	cmp	r0, r5
..........

    1004:	e5842000 	str	r2, [r4]
	WRITE_ONCE(next->prev, prev);
    1008:	e5813004 	str	r3, [r1, #4]
	WRITE_ONCE(prev->next, next);
    100c:	e5831000 	str	r1, [r3]
		*off = _off;
    1010:	e5875000 	str	r5, [r7]
		return skb;
    1014:	e1a00004 	mov	r0, r4
    1018:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	return NULL;
    101c:	e3a00000 	mov	r0, #0
}
    1020:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

我们发现在函数刚开始调用的时候，先将所有的寄存器的值入栈，这在中断也叫保存现场
在函数调用时，会生成一个栈帧，但这个栈帧的概念是我们人为创造的，实际上它不是一个立即的过程
一般来说我们会将当前的sp的值保存到fp中，fp也就是当前栈帧的基址，然后将参数给入栈














































